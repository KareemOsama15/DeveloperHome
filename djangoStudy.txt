django-admin startproject .  >>> Start a new django project in current dir

django-admin startapp app_name  >>> Start a new App in the project

python3 manage.py runserver   >>> Runs you project web app

python manage.py migrate  >>> Migrate the data structure of database in models of apps or the django default tables to be created and apply it in the database

python manage.py makemigrations app_name  >>> this describe the changes happened to the data structure that will be implememnted on the database and will generate a file called '0001_initial.py'


- we but in models.py the tabels we want to create and it inherit from (models.Model)

- when we create a new app we should but it in settings.py in web_app in the loit of (INSTALLED_APPS)

- when connect between mysql server and the django we need to but the details of database (ENGINE, NAME, USER, PASSWORD, HOST, PORT) in settings.py in web_app in the dictionary of (DATABASES)

- admin.py file can help to visualize the tables in database in admin page
from django.contrib import admin
from . import models
admin.site.register(models.app_name)

- serializers.py is used to describe the process of going from python object to json data format, so we first go to settings.py and add (rest_framework) in (INSTALLED_APPS), then we implement the process in serializers.py
from rest_framework import serializers
from .models import App

class AppSerializer(serializers.ModelSerializer):
    # here we build an inner class that will be the metadata describing the     # model
    class Meta:
        model = App
        fields = [model attributes for e.x, 'id', 'name']


- views.py the file that handle endpoints of app
from django.http import JsonResponse
from .models import App
from .serializers import AppSerializer

def endpoint(request):
    # here we do 3 things:
    # get all data of the model
    # serialize them
    # retuen JsonResponse
    data = App.object.all() # get all data
    serializer = AppSerializer(data, many=True)
    return  JsonResponse(serializer.data, safe=False)
    # safe=False this to allow non-dict objects to be serialized so we add it if we return serializer.data which is a list , and we can ignore if return a dict object

# we can also use more than http method in same function using same endpoint
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

@api_view(['GET', 'POST'])
def endpoint(request)
    if request.method == 'GET':
        data = App.object.all() # get all data
        serializer = AppSerializer(data, many=True)
        return  JsonResponse({'data': serializer.data})
    elif request.method == 'POST':
        serializer = AppSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=HTTP_201_CREATED)

# To get specific item
@api_views(['GET', 'PUT', 'DELETE'])
def endpoints(request, id):
    try:
        data = App.objects.get(pk=id)
    eccept App.DoesNotExists:
        return Response(status=HTTP_404_NOT_FOUND)
    
    if request.method == 'GET':
        serializer = AppSerializer(data)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = AppSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.error, status=HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        data.delete()
        return Response(status=HTTP_204_NO_CONTENT)



- urls.py the file that contains routes and define what url hit the view we ctreated, and this by creating a new path in urlpatterns list
from . import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('route/', views.endpoint),
    path('route/<int:id>, views.endpoints')
]



>>The Flow of Django<<
                          >> models
site.com <> urls <> views |
                          >> templates
